---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by javat.
--- DateTime: 2022/5/24 下午 12:44
---

--[==[
If the function has one single argument and that argument is either a literal string or a table constructor,
then the parentheses are optional:

print "Hello World" <--> print("Hello World")
dofile 'a.lua' <--> dofile ('a.lua')
print [[a multi-line
message]] <--> print([[a multi-line
message]])
f{x=10, y=20} <--> f({x=10, y=20})
type{} <--> type({})

]==]
print "Hello World"
dofile 'localvar.lua'
print [[a multi-line
message]]
print{x=10, y=20}
print(type{})

--[[
Lua also offers a special syntax for object-oriented calls, the colon operator.
An expression like o:foo(x) calls the method foo in the object o.
]]

--[[
A function definition has a name (add, in the example), a list of parameters, and a body,
which is a list of statements.
]]

-- add the elements of sequence 'a'
function add (a)
    local sum = 0
    for i = 1, #a do
        sum = sum + a[i]
    end
    return sum
end

--[[
We can call a function with a number of arguments different from its number of parameters.
Lua adjusts the number of arguments to the number of parameters by throwing away extra arguments
and supplying nils to extra parameters
]]

function f (a, b) print(a, b) end
f()--> nil nil
f(3)--> 3 nil
f(3, 4) --> 3 4
f(3, 4, 5) --> 3 4 (5 is discarded)

-- for default arguments
globalCounter =0
function incCount (n)
    n = n or 1 -- equivalent to specifying default value for argument n to be 1
    globalCounter = globalCounter + n
end

incCount()
print(globalCounter)

--[[
Multiple Results:
An unconventional but quite convenient feature of Lua is that functions can return multiple results.
Several predefined functions in Lua return multiple values. We have already seen the function string.find,
which locates a pattern in a string. This function returns two indices when it finds the pattern: the index of
the character where the match starts and the one where it ends. A multiple assignment allows the program
to get both results:
]]

s, e = string.find("hello Lua users", "Lua")
print(s, e) --> 7 9

-- a function to find the maximum element in a sequence can return both the maximum value and its location:
function maximum (a)
    local mi = 1
    -- index of the maximum value
    local m = a[mi]
    -- maximum value
    for i = 2, #a do
        if a[i] > m then
            mi = i; m = a[i]
        end
    end
    return m, mi
    -- return the maximum and its index
end
print('==1==')
fruits = { 'apple', 'banana', 'orange', 'kiwi', 'grape'}
m,mi = maximum(fruits)
print(m,mi)
m = maximum(fruits)
print(m)
_, mi = maximum(fruits)
print(mi)

--[[
Variadic Functions
A function can take a variable number of arguments.
The three dots (...) in the parameter list indicate that the function is variadic.
We call the three-dot expression a vararg expression. I
]]

function add (...)
    local s = 0
    for _, v in ipairs{...} do
        s = s + v
    end
    return s
end

print(add(3, 4, 10, 25, 12))--> 54

--[[
table.pack(...) function :
It receives any number of arguments and returns a new table with all its arguments
(just like {...}), but this table has also an extra field "n",
with the total number of arguments (including nils).
]]
function nonils (...)
    local arg = table.pack(...)
    for i = 1, arg.n do -- if instead using #arg to count the table length will stop before the first nil value
        if arg[i] == nil then return false end
    end
    return true
end

print(nonils(1,2,3,nil,4,5,nil,nil,nil))

print('==xxx==')
-- compare #t2 and t2.n
t = {1,2,3,nil,4,5,nil,nil,nil}
print(#t) -->3
print(t.n) -->nil
t2 = table.pack(1,2,3,nil,4,5,nil,nil,nil)
print(#t2) -->3
print(t2.n) -->9


--[[
Or use basic function, select()
select (index, ···)
If index is a number, returns all arguments after argument number index;
a negative number indexes from the end (-1 is the last argument).
Otherwise, index must be the string "#", and select returns the total number of extra arguments it received.
]]
i = 3
print(select(i, 3, 4, 10, 25, 12))
print(select("#", 3, 4, 10, 25, 12))

print(select(i, 3, 4, nil, 10, 25, 12, nil, nil, nil))
print(select("#", 3, 4, nil, 10, 25, 12, nil, nil, nil))

function nonils2 (...)
    for i = 1, select("#",...) do
        if select(i,...) == nil then return false end
    end
    return true
end

print(nonils2(1,2,3,nil,4,5,nil,nil,nil))

--[[
We can use select in places where its number of results is adjusted to one, so we can
think about select(n, ...) as returning its n-th extra argument.
]]

function add (...)
    local s = 0
    for i = 1, select("#", ...) do
        s = s + select(i, ...) -- use the first return value from select(i, ...), which is the ith element
    end
    return s
end

print(add(3, 4, 10, 25, 12))--> 54

--[[
The function table.unpack:
It takes a list and returns as results all elements from the list:

table.unpack is the reverse of table.pack.
While pack transforms a parameter list into a real Lua list (a table),
unpack transforms a real Lua list (a table) into a return list, which
can be given as the parameter list to another function.
]]
print(table.unpack{10,20,30})--> 10 20 30
a,b = table.unpack{10,20,30} -- a=10, b=20, 30 is discarded

-- trouble when the table is not a sequence
t = {1,2,3,nil,4,5,nil,nil,nil}
print(1,2,3,nil,4,5,nil,nil,nil)
print(table.unpack(t)) -- unpack stops before the first nil element