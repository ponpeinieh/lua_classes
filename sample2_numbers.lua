---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by javat.
--- DateTime: 2022/5/23 下午 10:43
---

--[[
Starting with version 5.3, Lua uses two alternative representations for numbers:
64-bit integer numbers, called simply integers, and
double-precision floating-point numbers, called simply floats.

We can write numeric constants with an optional decimal part plus an optional decimal exponent
> 4
> 0.4
> 4.57e-3
> 0.3e12
> 5E+20

Numerals with a decimal point or an exponent are considered floats; otherwise, they are treated as integers.
Both integer and float values have type "number":
]]

-- Arithmetic operators (lua behaviors like python)
--[[
If both operands are integers, the operation gives an integer result; otherwise, the operation results in a
float.
In case of mixed operands, Lua converts the integer one to a float before the operation:
> 13 + 15 -->28
> 13.0 + 15.0 -->28.0
> 13.0 + 25 -->38.0

Division does not follow that rule, because the division of two integers does not need to be an integer.
(In mathematical terms, we say that the integers are not closed under division.)
Division always operates on floats and gives float.
results:
> 3.0 / 2.0 -->1.5
> 3 / 2-->1.5

For integer division, Lua 5.3 introduced a new operator, called floor division and denoted by //.
Floor division always rounds the quotient towards minus infinity, ensuring an integral result for all operands.
If both operands are integers, the result is an integer; otherwise, the result is a float (with an integral value):

> 3 // 2 --> 1
> 3.0 // 2 --> 1.0
> 6 // 2 --> 3
> 6.0 // 2.0 --> 3.0
> -9 // 2 --> -5
> 1.5 // 0.5 --> 3.0

The following equation defines the modulo operator:
a % b == a - ((a // b) * b)
Integral operands ensure integral results, so this operator also follows the rule of other arithmetic
operations: if both operands are integers, the result is an integer; otherwise, the result is a float.

For integer operands, modulo has the usual meaning, with the result always having the same sign as the
second argument.
In particular, for any given positive constant K, the result of the expression x % K
is always in the range [0,K-1], even when x is negative.

For real operands, modulo has some unexpected uses. For instance, x - x % 0.01 is x with exactly
two decimal digits, and x - x % 0.001 is x with exactly three decimal digits:
> x = math.pi
> x - x%0.01 --> 3.14
> x - x%0.001 --> 3.141

]]

local tolerance = 10
function isturnback (angle)
    angle = angle % 360
    return (math.abs(angle - 180) < tolerance)
end
print(isturnback(-180))


-- an exponentiation operator,
--[[
Lua also offers an exponentiation operator, denoted by a caret (^). Like division, it always operates on
floats. (Integers are not closed under exponentiation; for instance, 2 is not an integer.) We can write
x^0.5 to compute the square root of x and x^(1/3) to compute its cubic root.
]]

--Relational Operators
--[[
the ~= operator is the negation of equality

Comparison of numbers always disregards their subtypes; it makes no difference whether the number is
represented as an integer or as a float.
]]

-- math module
--[[
> math.sin(math.pi / 2) -->1.0
> math.max(10.4, 7, -3, 20) -->20
> math.huge -->inf

All trigonometric functions work in radians. We can use the functions deg and rad to convert between
degrees and radians.

Random-number generator: math.random()

random() - return a random real number in the interval [0,1)
random(6) - return a random integer number in the interval [1,6]
random(10,20) - return a random integer number in the interval [10,20]

We can set a seed for the pseudo-random generator with the function randomseed.
A common trick to solve this problem is to use the current time as a seed:

math.randomseed(os.time())

]]

-- Rounding functions : ceil(), floor(), modf()
-- The math library offers three rounding functions: floor, ceil, and modf. Floor rounds towards minus
-- infinite, ceil rounds towards plus infinite, and modf rounds towards zero.

x = -3.3
i, f = math.modf(x)
print(i)
print(f)

-- Conversions
-- To force a number to be a float, we can simply add 0.0 to it.
-- To round a fractional number, we must explicitly call a rounding function.

--other operators: note that bitwise exclusive or is '~'
-- '^' is for exponent operator