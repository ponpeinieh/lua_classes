---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by javat.
--- DateTime: 2022/5/24 下午 12:44
---

--[[
Conditional statement:
1. if ... then ... end
2. if ... then ... else ... end
3. if ... then ... elseif ... then ... else ... end

while and repeat loop:
1. while ... do ... end
2. repeat ... until ...
]]

-- calculate square root of x
x = 121
sqrt_x = x/2
err = 1E-6
repeat
    sqrt_x = (x/sqrt_x + sqrt_x)/2
    print(string.format('The square root of %d is %.7f\n', x, sqrt_x))
until math.abs(sqrt_x*sqrt_x - x ) < err

--[[
3. numerical for :
        for var = exp1, exp2, exp3 do
            something
        end

This loop will execute something for each value of var from exp1 to exp2, using exp3 as the step to increment var.
This third expression is optional; when absent, Lua assumes 1 as the step value.

If we want a loop without an upper limit, we can use the constant math.huge

All three expressions are evaluated once, before the loop starts.

The control variable is a local variable automatically declared by the for statement,
and it is visible only inside the loop.

If you need the value of the control variable after the loop , you must save its value into another variable.

You should not change the value of the control variable: the effect of such changes is unpredictable.

If you want to end a for loop before its normal termination, use break.
]]

-- find a value in a list
a = { 1,3,11,-2,30,100}
local found = nil
for i = 1, #a do
    if a[i] < 0 then
        found = i -- save value of 'i'
        break
    end
end
print(found)

--[[
4. generic for :
        for e in i do
            something
        end
The generic for loop traverses all values returned by an iterator function i.
We saw some examples already, with pairs, ipairs, io.lines, etc.

The generic for can have multiple variables, which are all updated at each iteration.
The loop stops when the first variable gets nil.
The loop variables are local to the loop body and you should not change their values inside each iteration.
]]

--[[
break, return, and goto:

The break and return statements allow us to jump out of a block.
The goto statement allows us to jump to almost any point in a function.

A return can appear only as the last statement of a block: ie. the
last statement in our chunk or just before an end, an else, or an until.
This is because any statement following it would be unreachable.

Sometimes, it may be useful to write a return in the middle of a block; for instance,
we may be debugging a function and want to avoid its execution.
In such cases, we can use an explicit do block around the statement:

function foo ()
    return    --<< SYNTAX ERROR
    -- 'return' is the last statement in the next block
    do return end    -- OK
    other statements
end
]]


--[[
A goto statement jumps the execution of a program to a corresponding label.

In Lua, the syntax for a goto statement is quite conventional: it is the reserved word goto followed by the
label name, which can be any valid identifier.

The syntax for a label is a little more convoluted: it has two colons followed by the label name
followed by more two colons like in ::name::

This convolution is intentional, to highlight labels in a program.

A continue statement is simply a goto to a label at the end of a loop block;
]]